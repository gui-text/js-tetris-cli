{"version":3,"sources":["../../src/src/matrix.js"],"names":["Matrix","constructor","config","rows","columns","backgroundSymbols","frontColor","backgroundColor","i","Array","fill","placeBlocks","blocks","block","x","y","hasCollision","blockConfig","length","isAnyCollision","isOutOfBounds","isOccupied","clearLines","lines","getLinesToRemove","removeLines","numberOfBlocks","unshift","index","splice","tempArray","push","row","undefined","Symbol","iterator"],"mappings":"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","file":"matrix.js","sourcesContent":["/**\n * Matrix - tetris game playfield [well, grid, frame & etc]\n * https://tetris.fandom.com/wiki/Playfield\n *\n * @class Matrix\n */\nclass Matrix {\n    constructor(config) {\n        this.rows = config.rows;\n        this.columns = config.columns;\n        this.backgroundSymbols = config.backgroundSymbols;\n        this.frontColor = config.frontColor;\n        this.backgroundColor = config.backgroundColor;\n\n        // Create & fill zero-matrix (rows * columns) size\n        for (let i = 0; i < config.rows; i++) {\n            this[i] = new Array(config.columns).fill(0);\n        }\n    }\n\n    placeBlocks(blocks) {\n        for (const block of blocks) {\n            if (block &&\n                block.x > -1 &&\n                block.x < this.columns &&\n                block.y > -1 &&\n                block.y < this.rows) {\n\n                this[block.y][block.x] = block;\n            }\n        }\n    }\n\n    hasCollision(blocks) {\n        for (let y = 0; y < blocks.blockConfig.length; y++) {\n            for (let x = 0; x < blocks.blockConfig[0].length; x++) {\n                const isAnyCollision = (blocks.blockConfig[y][x] === 1) &&\n                                       (this.isOutOfBounds(blocks.x + x, blocks.y + y) ||\n                                        this.isOccupied(blocks.x + x, blocks.y + y));\n                if (isAnyCollision) {\n                    return true;\n                }\n            }\n        }\n        return false;\n    }\n\n    clearLines() {\n        const lines = this.getLinesToRemove();\n        return this.removeLines(lines);\n    }\n\n    getLinesToRemove() {\n        let lines = [];\n\n        for (let y = this.rows - 1; y >= 0; y--) {\n            let numberOfBlocks = 0;\n\n            for (let x = 0; x < this.columns; x++) {\n                if (this[y][x]) {\n                    numberOfBlocks += 1;\n                }\n            }\n\n            if (numberOfBlocks === 0) {\n                break;\n            } else if (numberOfBlocks < this.columns) {\n                continue;\n            } else if (numberOfBlocks === this.columns) {\n                lines.unshift(y);\n            }\n        }\n\n        return lines;\n    }\n\n    removeLines(lines) {\n        for (let index of lines) {\n            this.splice(index);\n            this.unshift(new Array(this.columns).fill(0));\n        }\n        return lines.length;\n    }\n\n    splice(index) {\n        let tempArray = [];\n\n        for (let i = 0; i < this.rows; i++) {\n            tempArray.push(this[i]);\n        }\n\n        for (let i = 0; i < index; i++) {\n            this[i] = tempArray[i];\n        }\n\n        for (let i = index + 1; i < this.rows; i++) {\n            this[i - 1] = tempArray[i];\n        }\n\n        this[this.rows] = new Array(this.columns).fill(1);\n    };\n\n    unshift(row) {\n        let tempArray = [];\n\n        for (let i = 0; i < this.rows; i++) {\n            tempArray.push(this[i]);\n        }\n\n        this[0] = row;\n\n        for (let i = 0; i < this.rows - 1; i++) {\n            this[i + 1] = tempArray[i];\n        }\n    };\n\n    isOutOfBounds(x, y) {\n        return this[y] === undefined || this[y][x] === undefined;\n    }\n\n    isOccupied(x, y) {\n        return this[y][x];\n    }\n\n    *[Symbol.iterator]() {\n        for (let y = 0; y < this.rows; y++) {\n            for (let x = 0; x < this.columns; x++) {\n                yield this[y][x];\n            }\n        }\n    }\n}\n\nexport default Matrix;\n"]}