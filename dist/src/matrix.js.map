{"version":3,"sources":["../../src/src/matrix.js"],"names":["Matrix","constructor","config","rows","columns","backgroundSymbols","frontColor","backgroundColor","i","Array","fill","placeBlocks","blocks","block","y","x","hasCollision","isOutOfBounds","isOccupied","clearLines","lines","getLinesToRemove","removeLines","numberOfBlocks","unshift","index","splice","length","undefined","Symbol","iterator"],"mappings":"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","file":"matrix.js","sourcesContent":["/**\n * Matrix - tetris game playfield [well, grid, frame & etc]\n * https://tetris.fandom.com/wiki/Playfield\n *\n * @class Matrix\n */\nclass Matrix {\n    constructor(config) {\n        this.rows = config.rows;\n        this.columns = config.columns;\n        this.backgroundSymbols = config.backgroundSymbols;\n        this.frontColor = config.frontColor;\n        this.backgroundColor = config.backgroundColor;\n\n        // Create & fill zero-matrix (rows * columns) size\n        for (let i = 0; i < config.rows; i++) {\n            this[i] = new Array(config.columns).fill(0);\n        }\n    }\n\n    placeBlocks(blocks) {\n        for (const block of blocks) {\n            if (block) {\n                this[block.y][block.x] = block;\n            }\n        }\n    }\n\n    hasCollision(blocks) {\n        for (const block of blocks) {\n            if (block &&\n                (this.isOutOfBounds(block.x, block.y) || this.isOccupied(block.x, block.y))) {\n                    return true;\n                }\n        }\n        return false;\n    }\n\n    clearLines() {\n        const lines = this.getLinesToRemove();\n        return this.removeLines(lines);\n    }\n\n    getLinesToRemove() {\n        let lines = [];\n\n        for (let y = this.rows - 1; y >= 0; y--) {\n            let numberOfBlocks = 0;\n\n            for (let x = 0; x < this.columns; x++) {\n                if (this[y][x]) {\n                    numberOfBlocks += 1;\n                }\n            }\n\n            if (numberOfBlocks === 0) {\n                break;\n            } else if (numberOfBlocks < this.columns) {\n                continue;\n            } else if (numberOfBlocks === this.columns) {\n                lines.unshift(y);\n            }\n        }\n\n        return lines;\n    }\n\n    removeLines(lines) {\n        for (let index of lines) {\n            this.splice(index, 1);\n            this.unshift(new Array(this.columns).fill(0));\n        }\n\n        return lines.length;\n    }\n\n    isOutOfBounds(x, y) {\n        return this[y] === undefined || this[y][x] === undefined;\n    }\n\n    isOccupied(x, y) {\n        return this[y][x];\n    }\n\n    *[Symbol.iterator]() {\n        for (let y = 0; y < this.rows; y++) {\n            for (let x = 0; x < this.columns; x++) {\n                yield this[y][x];\n            }\n        }\n    }\n}\n\nexport default Matrix;\n"]}